# dart-flutter-complete-developer

## Let's Dive In!

  ### How to Get Help
  
  ### Course Organization

## A Dart Introduction

  ### Dart Overview
  
  ### The Dartpad Editor
  
  ### Our First Program
  
  ### Pulling the Pieces Apart
  
  ### Functions in Dart
  
  ### Introduction to Types
  
  ### Why Use Types?
  
  ### String Interpolation
  
  ### Object Oriented Programming in Dart
  
  ### Creating Classes
  
  ### Creating Class Instances
  
  ### Constructor Functions
  
  ### Review on Constructors
  
  ### Completed Code

## Staying on Target with Dart

  ### App Overview
  
  ### OOP Design Flow
  
  ### Adding Fields to Classes
  
  ### Associated Methods
  
  ### More Initialization with Constructors
  
  ### For Loops
  
  ### Adding Elements to Lists
  
  ### More on Variable Initialization
  
  ### Customizing Print Statements
  
  ### ToString on Cards
  
  ### Shuffling a List
  
  ### Annotating Argument Types
  
  ### Filtering Lists
  
  ### Annotating Argument Types
  
  ### Filtering Lists
  
  ### Shorthand Function Syntax
  
  ### Removing Individual Records
  
  ### RemoveCard Implementation
  
  ### Named Parameters

## Flutter Environment Setup - MacOS

  ### Flutter Setup on MacOS
  
  ### SDK Extraction
  
  ### Editing the PATH Variable
  
  ### XCODE License
  
  ### Generating Flutter Projects

## MacOS Setup - Android

  ### Android Setup on MacOS
  
  ### Android Dependencies
  
  ### Android Project Setup
  
  ### More Android Dependencies!
  
  ### Android Emulator Creation
  
  ### Flutter Startup
  
  ### Finished Android Setup

## MacOS Setup - iOS

  ### iOS on Mac Setup
  
  ### XCode Setup
  
  ### iOS Simulator Startup
  
  ### App Startup

## Flutter Setup on PC

  ### Flutter Install
  
  ### More Flutter Installation
  
  ### Android Install
  
  ### Additional Dependencies
  
  ### Generating a Project
  
  ### Selecting an Image
  
  ### Starting the Emulator
  
  ### Finishing Android Setup

## App Building Time!

  ### Code Editor Setup
  
  ### What's Flutter About, Anyways?
  
  ### App Overview
  
  ### The Four Step Design Process
  
  ### Import Statements
  
  ### Creating Widgets
  
  ### Displaying Content on Screen
  
  ### Showing a Scaffold
  
  ### Customizing the App Bar
  
  ### Named Parameter Clarification
  
  ### Required Parameters
  
  ### Child Parameters
  
  ### Displaying Icons
  
  ### Adding Custom Widgets

## State Design with Flutter Apps

  ### Stateless vs Stateful Widgets
  
  ### The Build Method
  
  ### Local Import Statements
  
  ### Quick Breather and Review
  
  ### Refactoring Stateless to Stateful
  
  ### More Refactoring to Stateful Widgets

## High-Level Dart

  ### Generics in Dart
  
  ### Why Two Classes?

## HTTP Requests with Flutter

  ### Photos API
  
  ### Working with JSON
  
  ### Casting JSON to Model Instances
  
  ### Named Constructors
  
  ### Adding an Image Model
  
  ### Function References
  
  ### The HTTP Package
  
  ### Issuing HTTP Requests
  
  ### Handling Dart Futures
  
  ### Parsing Future Responses into a Model
  
  ### Updating the AppState Widget
  
  ### Building Lists of Widgets
  
  ### Sending Images to the ImageList
  
  ### The Final Keyword
  
  ### Building List of Widgets
  
  ### Sending Images to the ImageList
  
  ### The Final Keyword
  
  ### Building Lists with ListView
  
  ### Listing URL's
  
  ### Text to Images
  
  ### Containers for Positioning
  
  ### Adding Border Style
  
  ### Column Widgets for Layout
  
  ### Selective Padding
  
  ### App Review

## Forms and Validation with Flutter

  ### App Overview
  
  ### Boilerplate App Code
  
  ### Creating the Login Screen
  
  ### More Container Styling
  
  ### Labels and Hint Text
  
  ### Customizing Keyboard Type
  
  ### Handling Password Inputs
  
  ### Displaying Buttons with RaisedButton
  
  ### Changing Widgets Colors
  
  ### Layout Control
  
  ### Form Validation
  
  ### Referencing Widgets with Global Keys
  
  ### The Form Widget and Form State
  
  ### Creating a Global Key
  
  ### Referencing FormState with Global Keys
  
  ### Validating via FormState
  
  ### Triggering Validation
  
  ### Retrieving Form Values
  
  ### Final Form Submittal
  
  ### Code Reuse with Mixins
  
  ### Mixin Validator Implementation

## Reactive Programming with Dart

  ### A Quick Detour
  
  ### Streams by Analogy
  
  ### Characteristics of Streams
  
  ### StreamControllers and Sinks
  
  ### Mapping a Stream
  
  ### Adding a StreamTransformer
  
  ### Implementing the Listener
  
  ### Stream Review
  
  ### Let's Build a Game
  
  ### Why Streams?
  
  ### Word Guessing
  
  ### Stream's 'Take' and 'Where' Functions
  
  ### Validation with Streams
  
  ### Email Validation
  
  ### Wiring up the Error

## Advanced Flutter Architecture - The Bloc Pattern

  ### BLOC's vs Stateful Widgets
  
  ### The Purpose of Streams with Blocs
  
  ### Generating a New Project
  
  ### App Boilerplate
  
  ### Second Time on LoginScreen
  
  ### TextFields with RaisedButtons
  
  ### How to Use TextFields
  
  ### BLOC Design for TextFields
  
  ### Annotating Stream Types
  
  ### Issues with Bloc Access
  
  ### Shortcut Access with Getters
  
  ### Public vs Private Fields
  
  ### Improving the BLOC Api
  
  ### Validation Transformers
  
  ### A Technicality Around Mixins
  
  ### Cleaning Up Controllers
  
  ### Bloc Application

## Consuming BLOC Data

  ### The StreamBuilder Widget
  
  ### Streambuilder for Password Fields
  
  ### Scoped Bloc Approach
  
  ### Provider Implementation
  
  ### The Provider Implementation
  
  ### The Provider's 'of' Function
  
  ### The Provider's Constructor
  
  ### The Provider in Action
  
  ### Accesing the Bloc
  
  ### Breather and Review
  
  ### Enabling Form Submission
  
  ### Stream Merging Possibilities

## RxDart for Reactive Programming

  ### Introducing RxDart
  
  ### More on RxDart
  
  ### The CombineLastest Function
  
  ### CombineLatest in Action
  
  ### More on StreamBuilder
  
  ### Interpreting Stream Values
  
  ### Broadcast Streams
  
  ### Disabled by Default
  
  ### Replacing Controllers with Subjects
  
  ### Review of BLOCs

## Building Delightful Animations

  ### App Overview
  
  ### Animation Library Classes
  
  ### App Boilerplate
  
  ### StatefulWidgets for Animations
  
  ### Widget Structure
  
  ### Displaying a Cat
  
  ### The InitState Method
  
  ### Declaring the TickerProvider
  
  ### Tweens with Curves
  
  ### Performance Savings with AnimatedBuilder
  
  ### Nature of Animation
  
  ### Starting the Animation
  
  ### Watching for Taps with GestureDetector
  
  ### Reversing Animation States
  
  ### Building the Box
  
  ### Layouts with the Stack Widget
  
  ### Order of Drawing Widgets
  
  ### Add Center Widget
  
  ### Positioned Widgets
  
  ### Expanding Stack Dimensions
  
  ### Three Reasons for Strange Layouts
  
  ### Positioned Constrains
  
  ### Negative Offsets
  
  ### Stack Clip Settings
  
  ### Adjusting Tween Ranges
  
  ### Adding Box Flaps
  
  ### Rotating Widgets
  
  ### Rotation by Radians
  
  ### Changing Rotation Point
  
  ### A Touch of Positioning
  
  ### BoxAnimation Controller
  
  ### Adding Animated Builders
  
  ### Resetting Animations
  
  ### Constraining Animation Range
  
  ### Adding the Right Flap
  
  ### Negative Rotation Values
  
  ### Toggling Animation State
  
  ### Animation Wrapup

## Performant Data Fetching

  ### App Overview
  
  ### Hacker News API
  
  ### More API Challenges
  
  ### API Peformance Strategy
  
  ### Creating the ItemModel Class
  
  ### A Few More ItemModel Properties
  
  ### API Provider Implementation
  
  ### Fetching Individual Items

## Testing with Flutter and Dart

  ### Testing with Dart
  
  ### A Few Imports
  
  ### Writing Expectations
  
  ### Mocking HTTP Requests
  
  ### Returning JSON
  
  ### Testing FetchItem

## Offline Data Storage

  ### SQLite DB Provider
  
  ### Database Imports
  
  ### Async Constructors
  
  ### Creating a DB Connection
  
  ### Creating Tables with SQLite
  
  ### Adding Table Columns
  
  ### Issuing Queries
  
  ### Multiple Named Constructors
  
  ### Massaging DB Return Maps
  
  ### Turning Class Instances to Maps
  
  ### Implementing the Repository
  
  ### More on the Repository
  
  ### Type Annotations
  
  ### Casting Lists

## Type Design

  ### More on the Repository
  
  ### Abstract Classes
  
  ### The Need for Abstract Classes
  
  ### Why Abstract Classes?
  
  ### More on Abstract Classes
  
  ### Repository Interface Design
  
  ### Defining the Source
  
  ### Cache Definitions
  
  ### Lists of Sources and Caches
  
  ### Ultimate Reusability
  
  ### Quick Gotcha
  
  ### Another Quick Gotcha!
  
  ### FetchTopIds Implementation

## On Demand Widget Rendering

  ### App Setup
  
  ### A Touch of Boilerplate
  
  ### Data Fetching Concerns
  
  ### Solution Outline
  
  ### FutureBuilder in Action
  
  ### The Stories Provider
  
  ### Bloc Design
  
  ### Exposing Bloc Getters
  
  ### Wiring up the Stories Provider
  
  ### Bloc Testing
  
  ### Type Annotations Solve Problems
  
  ### Circular Progress Indicator
  
  ### Item Fetching Architecture
  
  ### Giant Gotcha with StreamBuilder
  
  ### Giant Gotcha Solution
  
  ### Implementing ScanStreamTransformer
  
  ### Finishing the ScanStreamTransformer
  
  ### Adding the Items Controller
  
  ### A Gotcha Around Streams? Impossibe!
  
  ### Single Transformer Application
  
  ### The ListView Tile
  
  ### StreamBuilder Setup
  
  ### Wrapping Up the FutureBuilder
  
  ### Double Gotcha!
  
  ### Stream Subscriptions
  
  ### Stream Subscription Fix
  
  ### Additional Streams
  
  ### A Laborious Refactor
  
  ### Result of Refactor
  
  ### Quick Debug Session
  
  ### Resolving Database Conflicts
  
  ### Building Story Tiles
  
  ### Comments Icon
  
  ### Applying Dividers with Height
  
  ### Loading Container Stand-in
  
  ### Building the Loading Container
  
  ### Showing the Loading Container
  
  ### Long-lived Cache Values
  
  ### Swipe to Refresh Indicator
  
  ### Implementing a Refresh Widget
  
  ### Clearing Database Tables
  
  ### Communicating a Future to onRefresh

## Navigation with Flutter

  ### Navigation in Flutter
  
  ### Map Based Routing
  
  ### OnGenerateRoute-Based Navigation
  
  ### OnGenereateRoute Implementation
  
  ### Navigating in Style!
  
  ### A PageRoute for NewsDetail
  
  ### A Scaffold in NewsDetail
  
  ### Parsing Route Settings
  
  ### The Comments Bloc Provider
  
  ### Comments Bloc Design
  
  ### More on Comments Bloc
  
  ### Recursive Data Fetching
  
  ### Quick Fix
  
  ### Connecting the Comments Provider
  
  ### Testing Recursive Fetching
  
  ### Consuming the Item Map
  
  ### Displaying the Story Title
  
  ### Text Styling
  
  ### Container Alignment
  
  ### Building the Comments List
  
  ### More Logic Extraction
  
  ### The Comment Widget
  
  ### Comment's FutureBuilder
  
  ### Showing Individual Comments
  
  ### Recursive Rendering
  
  ### Styling the Commment List
  
  ### Defaulting Null Values
  
  ### Handling Deleted Comments
  
  ### Nested Comments
  
  ### ListTile's ContentPadding Property
  
  ### Replacing Placeholder Characters
  
  ### Loading Containers for Comments
  
  ### App Wrapup
  
  ### Last Fix!

## Appendix One: Building Open Source with Dart

  ### Dart Local Installation
  
  ### Dart Install on Mac
  
  ### Editor Setup for Dart
  
  ### App Overview
  
  ### Folder and File Structure
  
  ### The PubSpec File
  
  ### Running Dart Files
  
  ### Program Design Methodology
  
  ### Class Creation
  
  ### Terminal Design
  
  ### Terminal Implementation
  
  ### Stdout and Stdin
  
  ### Import Statements
  
  ### Stdout Instance
  
  ### More on Import Statements
  
  ### Testing the Import Class
  
  ### Checking Operating System
  
  ### Clearing Windows Terminal
  
  ### Clearing Other Terminals
  
  ### Testing ClearScreen
  
  ### Collecting Input Over Stdin
  
  ### Option Class Fields
  
  ### Adding Dynamic Fields
  
  ### Printing Individual Options
  
  ### Testing Option Printing
  
  ### List Shortcomings
  
  ### Maps in Dart
  
  ### Refactor to Maps
  
  ### The Prompter Class
  
  ### Testing the Prompter
  
  ### Extracting the Terminal
  
  ### Var vs Final for Variables
  
  ### Final's Affect on Values
  
  ### Const's Dual Nature
  
  ### Const's Behavior by Type
  
  ### Marking Terminal as Const
  
  ### Private Variables
  
  ### Finishing Prompter
  
  ### Error Handling
  
  ### Asking Binary Questions
  
  ### Testing Binary Inputs
  
  ### Code Similarities
  
  ### Refactor for Code Reuse
  
  ### More on Private
  
  ### Central Lib File
  
  ### A Single Export Point
  
  ### A Relevant Example File
  
  ### Outstanding Project Config
  
  ### Uploading the Prompter Lib

## Apprendix Two: Building a Dart CLI

  ### App Overview
  
  ### Project Setup
  
  ### Importing Library Code
  
  ### Forcibly Exiting a Program
  
  ### Prompting for File Type
  
  ### Implementation Flow
  
  ### Working with the Current Directory
  
  ### Filtering Non-Files
  
  ### Filtering Non-Images
  
  ### Building Options from Images
  
  ### Testing Image Selection
  
  ### Converting Images
  
  ### The ConvertImage Function
  
  ### Reading File Contents
  
  ### Encoding to JPG or PNG
  
  ### Writing Files to the Hard Drive
  
  ### Returning the Image Name
  
  ### Testing Image Conversion
  
  ### Opening the Image

## References

- https://www.udemy.com/dart-and-flutter-the-complete-developers-guide/learn/v4/content
